<!DOCTYPE html>
<html>
  <head>
    <title>NFT Gift on Polygon | Receive</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
        height: 100vh;
        display: grid;
        font-size: 18px;
      }

      #app {
        align-self: center;
        justify-self: center;
      }

      .container {
        width: 300px;
        background-color: #eee;
        text-align: center;
        padding: 27px 18px;
        margin-bottom: 27px;
      }

      h1 {
        margin: 0;
        padding-bottom: 18px;
        font-size: 18px;
      }

      input,
      button {
        padding: 9px;
        font-size: 18px;
        margin-bottom: 9px;
      }

      input.full-width {
        display: block;
        margin: 0 auto;
        margin-bottom: 9px;
        text-align: center;
      }

      .info {
        max-width: 21ch;
        margin: 0 auto;
        margin-bottom: 18px;
        background-color: #ddd;
        padding: 12px 24px;
        word-wrap: break-word;
        font-family: "Lucida Console", Monaco, monospace;
        font-size: 15px;
      }

      a {
        color: black;
      }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.3.4/dist/web3.min.js"></script>
    <script>
      // custom methods
      async function fetchDarilka() {
        const response = await fetch(
                "{{ BACKEND_DARILKA_API }}",
                { method: "GET", mode: 'cors', headers: { 'Content-Type': 'application/json',}}
        );
        const res = await response.json();
        console.log('Requested api for darilka address, got', res);
        return res; // address, abi
      }

      async function fetchPostBooking(nft_contract, nft_token, sender_address, receiver_address, verification_code) {
        const response = await fetch(
                "{{ BACKEND_BOOK_API }}",
                {
                  method: "POST",
                  mode: 'cors',
                  headers: { 'Content-Type': 'application/json',},
                  body: JSON.stringify({
                    sender_address: sender_address,
                    receiver_address: receiver_address,
                    nft_token: nft_token,
                    nft_contract: nft_contract,
                    verification_code: verification_code})
                }
        );  // todo: hardcode
        const res = await response.json();
        console.log('Requested api for booking gift, got', res);
        return res.address;
      }

      // global consts
      window.userWeb3 = new Web3(window.ethereum)  // coz may be user already connect his metamask to www
      // the document use cookie to identify if user loggedIn or desired to logout
      // coz of in metamask to true logout user should do so with metamask!
      const metaMaskLoggedInCookie = "metaMaskLoggedIn=true"
      const metaMaskLoggedOutCookie = "metaMaskLoggedIn=false"
      let currentUserAddressGlobal = ""
      let darilkaContractGlobal = null
      const erc721Abi = [{ inputs: [ { internalType: "string", name: "name_", type: "string", }, { internalType: "string", name: "symbol_", type: "string", }, ], stateMutability: "nonpayable", type: "constructor", }, { anonymous: false, inputs: [ { indexed: true, internalType: "address", name: "owner", type: "address", }, { indexed: true, internalType: "address", name: "approved", type: "address", }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "Approval", type: "event", }, { anonymous: false, inputs: [ { indexed: true, internalType: "address", name: "owner", type: "address", }, { indexed: true, internalType: "address", name: "operator", type: "address", }, { indexed: false, internalType: "bool", name: "approved", type: "bool", }, ], name: "ApprovalForAll", type: "event", }, { anonymous: false, inputs: [ { indexed: true, internalType: "address", name: "from", type: "address", }, { indexed: true, internalType: "address", name: "to", type: "address", }, { indexed: true, internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "Transfer", type: "event", }, { inputs: [ { internalType: "bytes4", name: "interfaceId", type: "bytes4", }, ], name: "supportsInterface", outputs: [ { internalType: "bool", name: "", type: "bool", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "address", name: "owner", type: "address", }, ], name: "balanceOf", outputs: [ { internalType: "uint256", name: "", type: "uint256", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "ownerOf", outputs: [ { internalType: "address", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "name", outputs: [ { internalType: "string", name: "", type: "string", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "symbol", outputs: [ { internalType: "string", name: "", type: "string", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "tokenURI", outputs: [ { internalType: "string", name: "", type: "string", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "baseURI", outputs: [ { internalType: "string", name: "", type: "string", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "address", name: "owner", type: "address", }, { internalType: "uint256", name: "index", type: "uint256", }, ], name: "tokenOfOwnerByIndex", outputs: [ { internalType: "uint256", name: "", type: "uint256", }, ], stateMutability: "view", type: "function", }, { inputs: [], name: "totalSupply", outputs: [ { internalType: "uint256", name: "", type: "uint256", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "uint256", name: "index", type: "uint256", }, ], name: "tokenByIndex", outputs: [ { internalType: "uint256", name: "", type: "uint256", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "address", name: "to", type: "address", }, { internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "approve", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "getApproved", outputs: [ { internalType: "address", name: "", type: "address", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "address", name: "operator", type: "address", }, { internalType: "bool", name: "approved", type: "bool", }, ], name: "setApprovalForAll", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "owner", type: "address", }, { internalType: "address", name: "operator", type: "address", }, ], name: "isApprovedForAll", outputs: [ { internalType: "bool", name: "", type: "bool", }, ], stateMutability: "view", type: "function", }, { inputs: [ { internalType: "address", name: "from", type: "address", }, { internalType: "address", name: "to", type: "address", }, { internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "transferFrom", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "from", type: "address", }, { internalType: "address", name: "to", type: "address", }, { internalType: "uint256", name: "tokenId", type: "uint256", }, ], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function", }, { inputs: [ { internalType: "address", name: "from", type: "address", }, { internalType: "address", name: "to", type: "address", }, { internalType: "uint256", name: "tokenId", type: "uint256", }, { internalType: "bytes", name: "_data", type: "bytes", }, ], name: "safeTransferFrom", outputs: [], stateMutability: "nonpayable", type: "function", }]
      // user stage
      let userStageGlobal = 0;
      const DEBUG = false;

      // login methods
      function isMetaMaskLoggedInCookie() {
        return !!document.cookie.split(';').filter((item) => item.includes(metaMaskLoggedInCookie)).length;
      }

      function deleteMetaMaskLoggedInCookie() {
        document.cookie = metaMaskLoggedOutCookie;
      }

      const ethEnabled = async () => {
        if (typeof window.ethereum !== 'undefined') {
          console.log('MetaMask is installed!');
          return true
        }
        return false
      }

      async function loginWithMetaMask() {
        const accounts = await ethereum.request({ method: 'eth_requestAccounts' })
          .catch((e) => {
            console.error('could not login with metamask', e.message)
            return
          })
        if (!accounts) {
          return
        }
        window.userWeb3 = new Web3(window.ethereum)
        document.cookie = metaMaskLoggedInCookie
        console.log("new web3 created", window.userWeb3)
      }

      let authHtml = "";

      // const that will be injected on a special moment
      // i.e. link provided
      // todo: mb these vars should not be global
      let nftContractGlobal = '';  // for convenience
      let nftTokenGlobal = '';
      let passwordGlobal = '';
      let verificationCodeGlobal = '';
      let senderAddressGlobal = '';

      const render = async () => {

        // Network evm subscribers
        ethereum.on('accountsChanged', render);
        ethereum.on('disconnect', render);

        // init our EMV features on success login
        if (!await ethEnabled() && darilkaContract.address) {
          authHtml = `
            <div class="container">
              <h1>MetaMask Login</h1>
              <div class="info">MetaMask is not installed or not enabled. Check <a href="https://www.geeksforgeeks.org/how-to-install-and-use-metamask-on-google-chrome/" target="_blank">instruction</a>.</div>
              <button id="loginButtonId" disabled onclick="() => {}">Login is not enabled</button>
            </div>
          `;
        } else {
          authHtml = `
            <div class="container">
              <h1>MetaMask Login</h1>
              <div class="info" id="loginInfo">Proceed login with MetaMask.</div>
              <button id="loginButtonId" onclick="handleLogin()">Login</button>
            </div>
          `;
        }

        const accounts = await window.userWeb3.eth.getAccounts()
            .catch((e) => {
              console.error(e.message)
              return
            })

        if (!darilkaContractGlobal) {
          const darilkaContract = await fetchDarilka();
          darilkaContractGlobal = new window.userWeb3.eth.Contract(darilkaContract.abi, darilkaContract.address);
        }

        // our html frames
        let userHtml = "";
        let bookHtml = "";
        let transferHtml = "";
        let sumbitSpecialLinkHtml = "";
        let resultHtml = "";

        // where we will inject out htmls above
        const target = document.querySelector("#app");

        if (accounts.length && isMetaMaskLoggedInCookie()) {  // check both: metamask provider readiness & that user want to be logged in
          const networkId = await window.userWeb3.eth.net.getId();
          currentUserAddressGlobal = accounts[0];
          const userBalance = window.userWeb3.utils.fromWei(
            await window.userWeb3.eth.getBalance(currentUserAddressGlobal)
          );

          console.log('Current user', currentUserAddressGlobal)
          console.log('User balance', userBalance);

          authHtml = `
            <div class="container">
              <h1>User</h1>
              <div class="info">
                <a href="https://polygonscan.com/address/${currentUserAddressGlobal}" target="_blank">${currentUserAddressGlobal}</a>
              </div>
              <h1>NetworkId</h1>
              <div class="info">
                Currently frontend works for 137 (Polygon mainnet network id). Your NetworkId: ${networkId}.
                To change, e.g. <a href="https://coinmarketcap.com/alexandria/article/connect-metamask-to-polygon-network">use a link</a>.
              </div>
              <button onclick="handleLogout()">Logout</button>
            </div>
          `;
          if (userStageGlobal === 0 || DEBUG) {
            sumbitSpecialLinkHtml = `
            <div class="container">
              <h1>1. Past A Special Link</h1>
              <div class="info">A sender should give you the special link.</div>
              <div class="info">By submitting the link all necessary info fill be filled automatically, and only your acceptance on each step will be awaited.</div>
              <form onsubmit="handleSpecialLink(event)">
                <input type="text" name="special_link" class="full-width" required="required" placeholder="Special Link"/>
                <button id="btn-send-link" type="submit">Submit</button>
              </form>
            </div>
          `;
          }
          if (userStageGlobal === 1 || DEBUG) {
            bookHtml = `
              <div class="container">
                <h1>2. Book A Gift Through Backend</h1>
                <div class="info">Firstly you should book the gift with help of centralized backend. Thus, no one who looks to chain will pretend for the gift in the future.</div>
                <div class="info">In addition, a little amount of coins will be transferred to your account to make it possible to initiate NFT transfer from you account (but it may take a few seconds).</div>
                <form onsubmit="handleBook(event)">
                  <button id="btn-send-book" type="submit">Book</button>
                </form>
              </div>
            `;
          }
          if (userStageGlobal === 2 || DEBUG) {
            transferHtml = `
              <div class="container">
                <h1>3. Transfer The Gift Through Chain</h1>
                <div class="info">You will use allocated coins by sender in advance. Note, that coins transferring may need a few seconds to be completed since the previous step.</div>
                <form onsubmit="handleTransfer(event)">
                  <button id="btn-send-transfer" type="submit">Transfer</button>
                </form>
              </div>
            `;
          }
          if (userStageGlobal === 3 || DEBUG) {
            resultHtml = `
              <div class="container">
                <h1>Finally</h1>
                <div class="info">Your gift is transferred successfully.</div>
                <div class="info">You could check that you are an owner of the NFT via OpenSea, Rarible, other NFT-marketplaces or even via wallet app (but indexing process may take a while).</div>
                <div class="info">Transaction hash: .</div>
                <div class="info">To receive another gift merely refresh the page.</div>
              </div>
            `;
          }
        }
        target.innerHTML =
          authHtml + userHtml + sumbitSpecialLinkHtml + bookHtml + transferHtml + resultHtml;
      };

      const handleSpecialLink = async (e) => {
        e.preventDefault();
        const special_link = new FormData(e.target).get("special_link");
        if (special_link) {
          // todo: hardcode for link decoding
          specialLinkGlobal = special_link;
          const values = atob(special_link).split(":");
          if (!values.length === 5) {
            console.log("Wrong length for decoded special link", special_link.length);
            return
          }
          console.log('Insert values to global params...');

          senderAddressGlobal = values[0]
          nftContractGlobal = values[1];
          nftTokenGlobal = values[2];
          verificationCodeGlobal = values[3];
          passwordGlobal = values[4];

          userStageGlobal = 1;

          render();
        }
      };

      const handleBook = async (e) => {
        e.preventDefault();

        if (nftContractGlobal && nftTokenGlobal && verificationCodeGlobal && senderAddressGlobal) {
          const btnSendTxn = document.getElementById("btn-send-book");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Booking...";

          await fetchPostBooking(nftContractGlobal, nftTokenGlobal, senderAddressGlobal, currentUserAddressGlobal, verificationCodeGlobal);

          userStageGlobal = 2;

          render();
        }
      };

      const handleTransfer = async (e) => {
        e.preventDefault();

        if (nftContractGlobal && nftTokenGlobal && passwordGlobal && senderAddressGlobal) {
          const btnSendTxn = document.getElementById("btn-send-transfer");
          btnSendTxn.disabled = true;
          btnSendTxn.innerText = "Transferring...";


          const darilka = await fetchDarilka();

          let contract = new window.userWeb3.eth.Contract(
              darilka.abi,
              darilka.address
          );
          try {
            const result = await contract.methods
                    .performTransferNFT(senderAddressGlobal, currentUserAddressGlobal, nftContractGlobal, nftTokenGlobal, passwordGlobal)
                    .send({
                      from: currentUserAddressGlobal,
                    })
            console.log("result of transferring: ", result);

            userStageGlobal = 3;

            render();
          } catch (e) {
            console.log(e);
            window.alert("transaction failed, for more info check transaction via transaction hash");
            window.alert(e);
          }
        }
      };

      // ---- common handlers ----
      const handleLogin = async () => {
        await loginWithMetaMask();
        render()
      }

      const handleLogout = async () => {
        deleteMetaMaskLoggedInCookie();
        render();
      };
    </script>
  </head>
  <body onload="render()">
    <div id="app">
      <div class="container">Loading (awaiting MetaMask login)...</div>
    </div>
  </body>
</html>
